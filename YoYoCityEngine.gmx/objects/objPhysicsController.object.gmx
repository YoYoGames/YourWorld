<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//*****************************************************************************
// 
// Format:
//  string cellID (Example: "x12y5z2")
//  real   fixtureIndex (so we can reuse one of the right type)
//  real   phyInstID
//


physics_world_create(1/16);
physics_world_gravity(0.0, 0.0);


// Get infomation that we need
gridWidth  = oMap.MapWidth;
gridHeight = oMap.MapHeight;
halfRegion = 2;


// Setup lists
phyCache = ds_list_create();    // List of items from previous pass
phyActive = ds_list_create();   // List of currently active items
phyFree = ds_list_create();     // List of items that are free and ready for reuse


cellCenterX = 0;
cellCenterY = 0;


// Define shapes
PhysicsDefineBlock();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
preCenterX = cellCenterX;
preCenterY = cellCenterY;
cellCenterX = round(objBody.x/64);
cellCenterY = round(objBody.y/64);

// Do update if the player is in a new cell
if (cellCenterX != preCenterX)
|| (cellCenterY != preCenterY)
    {
    // Restrict region to inside the map (no point looking for things we know are not there)
    var startX = max(0, cellCenterX-halfRegion);
    var startY = max(0, cellCenterY-halfRegion);
    var endX = min(gridWidth, cellCenterX+halfRegion);
    var endY = min(gridHeight, cellCenterY+halfRegion);
    
    var xx, yy, cellID, existingCell;
    
    for (xx=startX; xx&lt;endX; xx++)
        {
        for (yy=startY; yy&lt;endY; yy++)
            {
            // Get uid for this cell
            cellID = "x"+string(xx)+"y"+string(yy)+"z"+string(0);
            
            // If this cell already has a body attached to it
            existingCell = ds_list_find_index(phyCache, cellID);
            if (existingCell != -1)
                {
                // Copy over to active list
                ds_list_add(phyActive, ds_list_find_value(phyCache, existingCell));
                ds_list_add(phyActive, ds_list_find_value(phyCache, existingCell+1));
                ds_list_add(phyActive, ds_list_find_value(phyCache, existingCell+2));
                
                // Remove from cache list
                ds_list_delete(phyCache, existingCell);
                ds_list_delete(phyCache, existingCell);
                ds_list_delete(phyCache, existingCell);
                }
                
            // There is nothing currently for this cell
            else if (ds_list_find_index(phyActive, cellID) == -1)
                {
                // Get type of cell
                cellValue = GetBlockIndex(xx, yy, 1);//ds_grid_get(objControl.chunkGrid, xx, yy);
                show_debug_message(string(cellValue));
                
                // If cell is a building
                if (cellValue == 10)
                    {
                    if (!ds_list_empty(phyFree))
                        {
                        index = max(0, ds_list_find_index(phyFree, cellID));
                        
                        // Get old cellID
                        oldID = ds_list_find_value(phyFree, index);
                        
                        // Get and move the instance
                        inst = ds_list_find_value(phyFree, index+2);
                        inst.phy_position_x = xx*512;
                        inst.phy_position_y = yy*512;
                        
                        // Get the type (later this could be adapted to swap fixture)
                        type = ds_list_find_value(phyFree, index+1);
                        
                        // Add all the to the active list
                        ds_list_add(phyActive, cellID);
                        ds_list_add(phyActive, type);
                        ds_list_add(phyActive, inst);
                        
                        // Delete the item from the free list
                        ds_list_delete(phyFree, index);
                        ds_list_delete(phyFree, index);
                        ds_list_delete(phyFree, index);
                        }
                    else
                        {
                        inst = instance_create(xx*512, yy*512, objFixture);
                        physics_fixture_bind(global.physicsBlock, inst);
                        ds_list_add(phyActive, cellID);
                        ds_list_add(phyActive, global.physicsBlock);
                        ds_list_add(phyActive, inst);
                        }
                    }
                }
            }
        }
    
    // Move leftover items from the cache list to free list
    for (n=0; n&lt;ds_list_size(phyCache); n+=3)
        {
        ds_list_add(phyFree, ds_list_find_value(phyCache, n));
        ds_list_add(phyFree, ds_list_find_value(phyCache, n+1));
        ds_list_add(phyFree, ds_list_find_value(phyCache, n+2));
        }
        
    ds_list_copy(phyCache, phyActive);  // Move active list to cache list
    ds_list_clear(phyActive);           // Clear the active list
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
draw_set_color(c_black);
draw_set_alpha(0.5);
draw_rectangle(0, 0, 256, 512, 0);

draw_set_color(c_white);
draw_set_alpha(1.0);

draw_text(8, 8, "Free List");
for (n=0; n&lt;ds_list_size(phyFree)/3; n++)
    {
    draw_text(8, 24+n*16, ds_list_find_value(phyFree, n*3));
    }

draw_text(96, 8, "Cache List");
for (n=0; n&lt;ds_list_size(phyCache)/3; n++)
    {
    draw_text(96, 24+n*16, ds_list_find_value(phyCache, n*3));
    }
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
